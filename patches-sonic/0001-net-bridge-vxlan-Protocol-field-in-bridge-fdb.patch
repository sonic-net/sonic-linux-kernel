From 68ffb9bebaf40bd843bd3c55a8642f9bc2e2558e Mon Sep 17 00:00:00 2001
From: "Barry Friedman (friedman)" <friedman@cisco.com>
Date: Fri, 13 Feb 2026 18:48:25 -0800
Subject: [PATCH] net: bridge: vxlan: Protocol field in bridge fdb

This is to add optional "protocol" field for bridge fdb entries.
The introduction of the 'protocol' field in the bridge FDB for EVPN Multihome, addresses the need to distinguish between MAC addresses learned via the control plane and those learned via the data plane with data plane aging. Specifically:
* A MAC address in an EVPN Multihome environment can be learned either through the control plane (static MAC) or the data plane (dynamic MAC with aging).
* The 'protocol' field uses values such as 'HW' for data plane dynamic MACs and 'ZEBRA' for control plane static MACs.
* This distinction allows the application to manage the MAC address state machine effectively during transitions, which can occur due to traffic hashing between EVPN Multihome peers or mobility of MAC addresses across EVPN peers.
* By identifying the source of the MAC learning (control plane vs. data plane), the system can handle MAC aging and mobility more accurately, ensuring synchronization between control and data planes and improving stability and reliability in MAC route handling.

This mechanism supports the complex state transitions and synchronization required in EVPN Multihome scenarios, where MAC addresses may move or be learned differently depending on network events and traffic patterns.

Change Summary:
vxlan_core.c:  Encode NDA_PROTOCOL, and create and update fdb protocol field
               Use RTPROT_UNSPEC when protocol not specified (default)
vxlan_private.h: protocol field in vxlan_fdb, function signature updates
vxlan_vnifilter.c: Use default RTPROT_UNSPEC, for default fdb create
br.c: Use default RTPROT_UNSPEC as protocol, for swdev event
br_fdb.c: Set NDA_PROTOCOL from protocol for fdb fill.
          bridge fdb add, delete, learn update of protocol field
br_private.h: protocol field in net_bridge_fdb_entry

e.g:
Test along with iproute2 change i.e https://lore.kernel.org/netdev/20250816031145.1153429-1-mrghosh@cisco.com/T/#u

$ bridge fdb add 00:00:00:00:00:88 dev hostbond2 vlan 1000 master dynamic extern_learn proto hw

$ bridge -d fdb show dev hostbond2 | grep 00:00:00:00:00:88
00:00:00:00:00:88 vlan 1000 extern_learn master br1000 proto hw

$ bridge -d -j -p fdb show dev hostbond2

...

[ {
        "mac": "00:00:00:00:00:88",
        "vlan": 1000,
        "flags": [ "extern_learn" ],
        "master": "br1000",
        "flags_ext": [ ],
        "protocol": "hw",
        "state": ""
    },{
...

Transition to Zebra:
$ bridge fdb replace  00:00:00:00:00:88 dev hostbond2 vlan 1000 master dynamic extern_learn proto zebra

$ bridge -d fdb show dev hostbond2 | grep 00:00:00:00:00:88
00:00:00:00:00:88 vlan 1000 extern_learn master br1000 proto zebra

$ bridge -d -j -p fdb show dev hostbond2 ...
[ {
        "mac": "00:00:00:00:00:88",
        "vlan": 1000,
        "flags": [ "extern_learn" ],
        "master": "br1000",
        "flags_ext": [ ],
        "protocol": "zebra",
        "state": ""
    },
...

iproute2 review: https://lore.kernel.org/netdev/20250816031145.1153429-1-mrghosh@cisco.com/T/#u

Signed-off-by: Mrinmoy Ghosh <mrghosh@cisco.com>
---
 drivers/net/vxlan/vxlan_core.c      | 55 +++++++++++++++++++----------
 drivers/net/vxlan/vxlan_private.h   |  5 +--
 drivers/net/vxlan/vxlan_vnifilter.c |  4 +--
 net/bridge/br.c                     |  2 +-
 net/bridge/br_fdb.c                 | 55 ++++++++++++++++++++---------
 net/bridge/br_private.h             |  5 +--
 6 files changed, 85 insertions(+), 41 deletions(-)

diff --git a/drivers/net/vxlan/vxlan_core.c b/drivers/net/vxlan/vxlan_core.c
index de1b3fa96..c34b9f75c 100644
--- a/drivers/net/vxlan/vxlan_core.c
+++ b/drivers/net/vxlan/vxlan_core.c
@@ -200,6 +200,8 @@ static int vxlan_fdb_info(struct sk_buff *skb, struct vxlan_dev *vxlan,
 			peernet2id(dev_net(vxlan->dev), vxlan->net)))
 		goto nla_put_failure;
 
+	if (nla_put_u8(skb, NDA_PROTOCOL, fdb->protocol))
+		goto nla_put_failure;
 	if (send_eth && nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->eth_addr))
 		goto nla_put_failure;
 	if (nh) {
@@ -888,7 +890,7 @@ static int vxlan_fdb_nh_update(struct vxlan_dev *vxlan, struct vxlan_fdb *fdb,
 int vxlan_fdb_create(struct vxlan_dev *vxlan, const u8 *mac,
 		     union vxlan_addr *ip, __u16 state, __be16 port,
 		     __be32 src_vni, __be32 vni, __u32 ifindex, __u16 ndm_flags,
-		     u32 nhid, struct vxlan_fdb **fdb,
+		     u32 nhid, u8 protocol, struct vxlan_fdb **fdb,
 		     struct netlink_ext_ack *extack, u32 ext_flags)
 {
 	struct vxlan_rdst *rd = NULL;
@@ -904,6 +906,7 @@ int vxlan_fdb_create(struct vxlan_dev *vxlan, const u8 *mac,
 	if (!f)
 		return -ENOMEM;
 
+	f->protocol = protocol;
 	if (nhid)
 		rc = vxlan_fdb_nh_update(vxlan, f, nhid, extack);
 	else
@@ -981,7 +984,7 @@ static int
 vxlan_fdb_update_existing(struct vxlan_dev *vxlan, union vxlan_addr *ip,
 			  __u16 state, __u16 flags, __be16 port, __be32 vni,
 			  __u32 ifindex, __u16 ndm_flags, struct vxlan_fdb *f,
-			  u32 nhid, bool swdev_notify,
+			  u32 nhid, u8 protocol, bool swdev_notify,
 			  struct netlink_ext_ack *extack, u32 ext_flags)
 {
 	__u16 fdb_flags = (ndm_flags & ~NTF_USE);
@@ -1019,6 +1022,11 @@ vxlan_fdb_update_existing(struct vxlan_dev *vxlan, union vxlan_addr *ip,
 			WRITE_ONCE(f->updated, jiffies);
 			notify = 1;
 		}
+		if (f->protocol != protocol) {
+			f->protocol = protocol;
+			WRITE_ONCE(f->updated, jiffies);
+			notify = 1;
+		}
 	}
 
 	if ((old_ext_flags ^ ext_flags) & NTF_EXT_MH_PEER_SYNC) {
@@ -1088,7 +1096,7 @@ static int vxlan_fdb_update_create(struct vxlan_dev *vxlan, const u8 *mac,
 				   union vxlan_addr *ip, __u16 state,
 				   __u16 flags, __be16 port, __be32 src_vni,
 				   __be32 vni, __u32 ifindex, __u16 ndm_flags,
-				   u32 nhid, bool swdev_notify,
+				   u32 nhid, u8 protocol, bool swdev_notify,
 				   struct netlink_ext_ack *extack,
 				   u32 ext_flags)
 {
@@ -1103,7 +1111,8 @@ static int vxlan_fdb_update_create(struct vxlan_dev *vxlan, const u8 *mac,
 
 	netdev_dbg(vxlan->dev, "add %pM -> %pIS\n", mac, ip);
 	rc = vxlan_fdb_create(vxlan, mac, ip, state, port, src_vni, vni,
-			      ifindex, fdb_flags, nhid, &f, extack, ext_flags);
+			      ifindex, fdb_flags, nhid, protocol, &f, extack,
+			      ext_flags);
 	if (rc < 0)
 		return rc;
 
@@ -1124,7 +1133,7 @@ static int vxlan_fdb_update_create(struct vxlan_dev *vxlan, const u8 *mac,
 int vxlan_fdb_update(struct vxlan_dev *vxlan, const u8 *mac,
 		     union vxlan_addr *ip, __u16 state, __u16 flags,
 		     __be16 port, __be32 src_vni, __be32 vni, __u32 ifindex,
-		     __u16 ndm_flags, u32 nhid, bool swdev_notify,
+		     __u16 ndm_flags, u32 nhid, u8 protocol, bool swdev_notify,
 		     struct netlink_ext_ack *extack, u32 ext_flags)
 {
 	struct vxlan_fdb *f;
@@ -1139,16 +1148,16 @@ int vxlan_fdb_update(struct vxlan_dev *vxlan, const u8 *mac,
 
 		return vxlan_fdb_update_existing(vxlan, ip, state, flags, port,
 						 vni, ifindex, ndm_flags, f,
-						 nhid, swdev_notify, extack,
-						 ext_flags);
+						 nhid, protocol, swdev_notify,
+						 extack, ext_flags);
 	} else {
 		if (!(flags & NLM_F_CREATE))
 			return -ENOENT;
 
 		return vxlan_fdb_update_create(vxlan, mac, ip, state, flags,
 					       port, src_vni, vni, ifindex,
-					       ndm_flags, nhid, swdev_notify,
-					       extack, ext_flags);
+					       ndm_flags, nhid, protocol,
+					       swdev_notify, extack, ext_flags);
 	}
 }
 
@@ -1162,7 +1171,7 @@ static void vxlan_fdb_dst_destroy(struct vxlan_dev *vxlan, struct vxlan_fdb *f,
 
 static int vxlan_fdb_parse(struct nlattr *tb[], struct vxlan_dev *vxlan,
 			   union vxlan_addr *ip, __be16 *port, __be32 *src_vni,
-			   __be32 *vni, u32 *ifindex, u32 *nhid,
+			   __be32 *vni, u32 *ifindex, u32 *nhid, u8 *protocol,
 			   struct netlink_ext_ack *extack, u32 *ext_flags)
 {
 	struct net *net = dev_net(vxlan->dev);
@@ -1252,6 +1261,11 @@ static int vxlan_fdb_parse(struct nlattr *tb[], struct vxlan_dev *vxlan,
 		*ext_flags = 0;
 	}
 
+	if (tb[NDA_PROTOCOL])
+		*protocol = nla_get_u8(tb[NDA_PROTOCOL]);
+	else
+		*protocol = RTPROT_UNSPEC;
+
 	return 0;
 }
 
@@ -1269,6 +1283,7 @@ static int vxlan_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 	u32 ifindex, nhid;
 	u32 hash_index;
 	u32 ext_flags;
+	u8 protocol;
 	int err;
 
 	if (!(ndm->ndm_state & (NUD_PERMANENT|NUD_REACHABLE))) {
@@ -1281,7 +1296,7 @@ static int vxlan_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 		return -EINVAL;
 
 	err = vxlan_fdb_parse(tb, vxlan, &ip, &port, &src_vni, &vni, &ifindex,
-			      &nhid, extack, &ext_flags);
+			      &nhid, &protocol, extack, &ext_flags);
 	if (err)
 		return err;
 
@@ -1293,7 +1308,7 @@ static int vxlan_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 	err = vxlan_fdb_update(vxlan, addr, &ip, ndm->ndm_state, flags, port,
 			       src_vni, vni, ifindex,
 			       ndm->ndm_flags | NTF_VXLAN_ADDED_BY_USER, nhid,
-			       true, extack, ext_flags);
+			       protocol, true, extack, ext_flags);
 	spin_unlock_bh(&vxlan->hash_lock[hash_index]);
 
 	return err;
@@ -1345,10 +1360,11 @@ static int vxlan_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 	u32 hash_index;
 	u32 ext_flags;
 	__be16 port;
+	u8 protocol;
 	int err;
 
 	err = vxlan_fdb_parse(tb, vxlan, &ip, &port, &src_vni, &vni, &ifindex,
-			      &nhid, extack, &ext_flags);
+			      &nhid, &protocol, extack, &ext_flags);
 	if (err)
 		return err;
 
@@ -1508,7 +1524,8 @@ static bool vxlan_snoop(struct net_device *dev,
 					 NLM_F_EXCL | NLM_F_CREATE,
 					 vxlan->cfg.dst_port, vni,
 					 vxlan->default_dst.remote_vni, ifindex,
-					 NTF_SELF, 0, true, NULL, 0);
+					 NTF_SELF, 0, RTPROT_UNSPEC, true, NULL,
+					 0);
 		spin_unlock(&vxlan->hash_lock[hash_index]);
 	}
 
@@ -3960,7 +3977,8 @@ static int __vxlan_dev_create(struct net *net, struct net_device *dev,
 				       NUD_REACHABLE | NUD_PERMANENT,
 				       vxlan->cfg.dst_port, dst->remote_vni,
 				       dst->remote_vni, dst->remote_ifindex,
-				       NTF_SELF, 0, &f, extack, 0);
+				       NTF_SELF, 0, RTPROT_UNSPEC, &f, extack,
+				       0);
 		if (err)
 			return err;
 	}
@@ -4393,7 +4411,8 @@ static int vxlan_changelink(struct net_device *dev, struct nlattr *tb[],
 					       NLM_F_APPEND | NLM_F_CREATE,
 					       vxlan->cfg.dst_port, conf.vni,
 					       conf.vni, conf.remote_ifindex,
-					       NTF_SELF, 0, true, extack, 0);
+					       NTF_SELF, 0, RTPROT_UNSPEC, true,
+					       extack, 0);
 			if (err) {
 				spin_unlock_bh(&vxlan->hash_lock[hash_index]);
 				netdev_adjacent_change_abort(dst->remote_dev,
@@ -4745,8 +4764,8 @@ vxlan_fdb_external_learn_add(struct net_device *dev,
 			       NUD_REACHABLE, NLM_F_CREATE | NLM_F_REPLACE,
 			       fdb_info->remote_port, fdb_info->vni,
 			       fdb_info->remote_vni, fdb_info->remote_ifindex,
-			       NTF_USE | NTF_SELF | NTF_EXT_LEARNED, 0, false,
-			       extack, 0);
+			       NTF_USE | NTF_SELF | NTF_EXT_LEARNED, 0,
+			       RTPROT_UNSPEC, false, extack, 0);
 	spin_unlock_bh(&vxlan->hash_lock[hash_index]);
 
 	return err;
diff --git a/drivers/net/vxlan/vxlan_private.h b/drivers/net/vxlan/vxlan_private.h
index 7789af637..77ffbc856 100644
--- a/drivers/net/vxlan/vxlan_private.h
+++ b/drivers/net/vxlan/vxlan_private.h
@@ -36,6 +36,7 @@ struct vxlan_fdb {
 	__be32		  vni;
 	u16		  flags;	/* see ndm_flags and below */
 	u32 ext_flags;
+	u8 protocol;
 	struct list_head  nh_list;
 	struct nexthop __rcu *nh;
 	struct vxlan_dev  __rcu *vdev;
@@ -179,7 +180,7 @@ vxlan_vnifilter_lookup(struct vxlan_dev *vxlan, __be32 vni)
 int vxlan_fdb_create(struct vxlan_dev *vxlan, const u8 *mac,
 		     union vxlan_addr *ip, __u16 state, __be16 port,
 		     __be32 src_vni, __be32 vni, __u32 ifindex, __u16 ndm_flags,
-		     u32 nhid, struct vxlan_fdb **fdb,
+		     u32 nhid, u8 protocol, struct vxlan_fdb **fdb,
 		     struct netlink_ext_ack *extack, u32 ext_flags);
 int __vxlan_fdb_delete(struct vxlan_dev *vxlan,
 		       const unsigned char *addr, union vxlan_addr ip,
@@ -190,7 +191,7 @@ u32 fdb_head_index(struct vxlan_dev *vxlan, const u8 *mac, __be32 vni);
 int vxlan_fdb_update(struct vxlan_dev *vxlan, const u8 *mac,
 		     union vxlan_addr *ip, __u16 state, __u16 flags,
 		     __be16 port, __be32 src_vni, __be32 vni, __u32 ifindex,
-		     __u16 ndm_flags, u32 nhid, bool swdev_notify,
+		     __u16 ndm_flags, u32 nhid, u8 protocol, bool swdev_notify,
 		     struct netlink_ext_ack *extack, u32 ext_flags);
 void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,
 		    __be32 default_vni, struct vxlan_rdst *rdst, bool did_rsc);
diff --git a/drivers/net/vxlan/vxlan_vnifilter.c b/drivers/net/vxlan/vxlan_vnifilter.c
index ad1a46242..f8396be44 100644
--- a/drivers/net/vxlan/vxlan_vnifilter.c
+++ b/drivers/net/vxlan/vxlan_vnifilter.c
@@ -493,8 +493,8 @@ static int vxlan_update_default_fdb_entry(struct vxlan_dev *vxlan, __be32 vni,
 				       NUD_REACHABLE | NUD_PERMANENT,
 				       NLM_F_APPEND | NLM_F_CREATE,
 				       vxlan->cfg.dst_port, vni, vni,
-				       dst->remote_ifindex, NTF_SELF, 0, true,
-				       extack, 0);
+				       dst->remote_ifindex, NTF_SELF, 0,
+				       RTPROT_UNSPEC, true, extack, 0);
 		if (err) {
 			spin_unlock_bh(&vxlan->hash_lock[hash_index]);
 			return err;
diff --git a/net/bridge/br.c b/net/bridge/br.c
index 6b8c782f2..ab533d843 100644
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@ -167,7 +167,7 @@ static int br_switchdev_event(struct notifier_block *unused,
 		fdb_info = ptr;
 		err = br_fdb_external_learn_add(br, p, fdb_info->addr,
 						fdb_info->vid, fdb_info->locked,
-						false, 0);
+						false, 0, RTPROT_UNSPEC);
 		if (err) {
 			err = notifier_from_errno(err);
 			break;
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 202d79183..4648ca1cd 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -132,6 +132,8 @@ static int fdb_fill_info(struct sk_buff *skb, const struct net_bridge *br,
 		goto nla_put_failure;
 	if (nla_put_u32(skb, NDA_MASTER, br->dev->ifindex))
 		goto nla_put_failure;
+	if (nla_put_u8(skb, NDA_PROTOCOL, fdb->protocol))
+		goto nla_put_failure;
 	if (nla_put_u32(skb, NDA_FLAGS_EXT, ext_flags))
 		goto nla_put_failure;
 
@@ -1163,7 +1165,8 @@ static int fdb_add_entry(struct net_bridge *br, struct net_bridge_port *source,
 
 static int __br_fdb_add(struct ndmsg *ndm, struct net_bridge *br,
 			struct net_bridge_port *p, const unsigned char *addr,
-			u16 nlh_flags, u16 vid, struct nlattr *nfea_tb[],
+			u16 nlh_flags, u16 vid, u8 protocol,
+			struct nlattr *nfea_tb[],
 			struct netlink_ext_ack *extack, u32 ext_flags)
 {
 	int err = 0;
@@ -1188,8 +1191,8 @@ static int __br_fdb_add(struct ndmsg *ndm, struct net_bridge *br,
 					   "FDB entry towards bridge must be permanent");
 			return -EINVAL;
 		}
-		err = br_fdb_external_learn_add(br, p, addr, vid, false, true,
-						ext_flags);
+		err = br_fdb_external_learn_add(br, p, addr, vid, protocol,
+						false, true, ext_flags);
 	} else {
 		spin_lock_bh(&br->hash_lock);
 		err = fdb_add_entry(br, p, addr, ndm, nlh_flags, vid, nfea_tb);
@@ -1215,6 +1218,7 @@ int br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 	struct net_bridge_port *p = NULL;
 	struct net_bridge_vlan *v;
 	struct net_bridge *br = NULL;
+	u8 protocol = RTPROT_UNSPEC;
 	u32 ext_flags = 0;
 	int err = 0;
 
@@ -1273,11 +1277,11 @@ int br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 		}
 
 		/* VID was specified, so use it. */
-		err = __br_fdb_add(ndm, br, p, addr, nlh_flags, vid, nfea_tb,
-				   extack, ext_flags);
+		err = __br_fdb_add(ndm, br, p, addr, nlh_flags, vid, protocol,
+				   nfea_tb, extack, ext_flags);
 	} else {
-		err = __br_fdb_add(ndm, br, p, addr, nlh_flags, 0, nfea_tb,
-				   extack, ext_flags);
+		err = __br_fdb_add(ndm, br, p, addr, nlh_flags, 0, protocol,
+				   nfea_tb, extack, ext_flags);
 		if (err || !vg || !vg->num_vlans)
 			goto out;
 
@@ -1289,7 +1293,8 @@ int br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 			if (!br_vlan_should_use(v))
 				continue;
 			err = __br_fdb_add(ndm, br, p, addr, nlh_flags, v->vid,
-					   nfea_tb, extack, ext_flags);
+					   protocol, nfea_tb, extack,
+					   ext_flags);
 			if (err)
 				goto out;
 		}
@@ -1301,7 +1306,7 @@ int br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 
 static int fdb_delete_by_addr_and_port(struct net_bridge *br,
 				       const struct net_bridge_port *p,
-				       const u8 *addr, u16 vlan)
+				       const u8 *addr, u16 vlan, u8 protocol)
 {
 	struct net_bridge_fdb_entry *fdb;
 
@@ -1309,6 +1314,14 @@ static int fdb_delete_by_addr_and_port(struct net_bridge *br,
 	if (!fdb || READ_ONCE(fdb->dst) != p)
 		return -ENOENT;
 
+	/* If the delete comes from a different protocol type,
+	* that type is used in the notification as some software
+	* may be expecting multiple deletes (control learned +
+	* hardware datapath learned)
+	*/
+	if (protocol != RTPROT_UNSPEC)
+		fdb->protocol = protocol;
+
 	fdb_delete(br, fdb, true);
 
 	return 0;
@@ -1316,12 +1329,12 @@ static int fdb_delete_by_addr_and_port(struct net_bridge *br,
 
 static int __br_fdb_delete(struct net_bridge *br,
 			   const struct net_bridge_port *p,
-			   const unsigned char *addr, u16 vid)
+			   const unsigned char *addr, u16 vid, u8 protocol)
 {
 	int err;
 
 	spin_lock_bh(&br->hash_lock);
-	err = fdb_delete_by_addr_and_port(br, p, addr, vid);
+	err = fdb_delete_by_addr_and_port(br, p, addr, vid, protocol);
 	spin_unlock_bh(&br->hash_lock);
 
 	return err;
@@ -1335,10 +1348,14 @@ int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 {
 	struct net_bridge_vlan_group *vg;
 	struct net_bridge_port *p = NULL;
+	u8 protocol = RTPROT_UNSPEC;
 	struct net_bridge_vlan *v;
 	struct net_bridge *br;
 	int err;
 
+	if (tb[NDA_PROTOCOL])
+		protocol = nla_get_u8(tb[NDA_PROTOCOL]);
+
 	if (netif_is_bridge_master(dev)) {
 		br = netdev_priv(dev);
 		vg = br_vlan_group(br);
@@ -1360,17 +1377,17 @@ int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 			return -EINVAL;
 		}
 
-		err = __br_fdb_delete(br, p, addr, vid);
+		err = __br_fdb_delete(br, p, addr, vid, protocol);
 	} else {
 		err = -ENOENT;
-		err &= __br_fdb_delete(br, p, addr, 0);
+		err &= __br_fdb_delete(br, p, addr, 0, protocol);
 		if (!vg || !vg->num_vlans)
 			return err;
 
 		list_for_each_entry(v, &vg->vlan_list, vlist) {
 			if (!br_vlan_should_use(v))
 				continue;
-			err &= __br_fdb_delete(br, p, addr, v->vid);
+			err &= __br_fdb_delete(br, p, addr, v->vid, protocol);
 		}
 	}
 
@@ -1430,8 +1447,8 @@ void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p)
 }
 
 int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
-			      const unsigned char *addr, u16 vid, bool locked,
-			      bool swdev_notify, u32 ext_flags)
+			      const unsigned char *addr, u16 vid, u8 protocol,
+			      bool locked, bool swdev_notify, u32 ext_flags)
 {
 	struct net_bridge_fdb_entry *fdb;
 	bool modified = false;
@@ -1465,6 +1482,7 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 			err = -ENOMEM;
 			goto err_unlock;
 		}
+		fdb->protocol = protocol;
 		fdb_notify(br, fdb, RTM_NEWNEIGH, swdev_notify);
 	} else {
 		if (locked &&
@@ -1512,6 +1530,11 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 		    test_and_clear_bit(BR_FDB_DYNAMIC_LEARNED, &fdb->flags))
 			atomic_dec(&br->fdb_n_learned);
 
+		if (fdb->protocol != protocol) {
+			modified = true;
+			fdb->protocol = protocol;
+		}
+
 		if (modified)
 			fdb_notify(br, fdb, RTM_NEWNEIGH, swdev_notify);
 	}
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2376178ec..c69efd1e4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -292,6 +292,7 @@ struct net_bridge_fdb_entry {
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
 	unsigned long			flags;
+	u8 protocol;
 
 	/* write-heavy members should not affect lookups */
 	unsigned long			updated ____cacheline_aligned_in_smp;
@@ -869,8 +870,8 @@ int br_fdb_get(struct sk_buff *skb, struct nlattr *tb[], struct net_device *dev,
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
 void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
-			      const unsigned char *addr, u16 vid, bool locked,
-			      bool swdev_notify, u32 ext_flags);
+			      const unsigned char *addr, u16 vid, u8 protocol,
+			      bool locked, bool swdev_notify, u32 ext_flags);
 int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid,
 			      bool swdev_notify);
-- 
2.34.1

